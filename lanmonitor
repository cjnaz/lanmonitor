#!/usr/bin/env python3
"""LAN monitor

Monitor status of network resources, such as services, hosts, file system age, system update age, etc.
See README.md for descriptions of available plugins.

Operates interactively or as a service (loop forever and controlled via systemd or other).
"""

__version__ = "V2.0 221130"

#==========================================================
#
#  Chris Nelson, 2021-2022
#
# V2.0  221130  check_interval per item, dropped --once, added --service 
# V1.5  221120  Added --print-log switch, Summaries are optional if SummaryDays is not defined.
# V1.4  220420  Incorporated funcs3 timevalue and retime
# V1.3  220217  Updates for funcs3 V1.0, stock_notif catch of emailer fails.
# V1.2  210605  Reworked have_access check to check_LAN_access logic.
# V1.1  210523  Added loadconfig flush_on_reload to purge any deleted cfg keys.  Error formatting tweaks.
# V1.0  210507  Major refactor
# V0.1  210129  Initial
#
# Changes pending
#   
#==========================================================

import sys
import argparse
import time
import datetime
import os.path
import subprocess
import signal


sys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), '../funcs3/'))
from funcs3 import PROGDIR, loadconfig, getcfg, cfg, logging, funcs3_min_version_check, funcs3_version, timevalue

import globvars
import lanmonfuncs


# Configs / Constants
PY_MIN_VERSION         = 3.6
FUNCS3_MIN_VERSION     = 1.1
CONFIG_FILE            = os.path.join(PROGDIR, 'lanmonitor.cfg')
CONSOLE_LOGGING_FORMAT = '{levelname:>8}:  {message}'


def main():

    first = True
    inst_dict = {}
    notif_handlers_list = []
    monline = {}


    while 1:
        reloaded = loadconfig(cfgfile = globvars.args.config_file, flush_on_reload=True, cfglogfile=None, cfglogfile_wins=logfile_override) #, cfgloglevel=10)

        if not globvars.args.service:               # In service mode, logging level is set from config file
            if globvars.args.verbose == 1:
                logging.getLogger().setLevel(logging.INFO)
            elif globvars.args.verbose == 2:
                logging.getLogger().setLevel(logging.DEBUG)
            else:
                logging.getLogger().setLevel(logging.WARNING)

        if first:
            if globvars.args.service:
                time.sleep (timevalue(getcfg('StartupDelay')).seconds)
            reloaded = True                         # Force calc of key and host padding lengths

        if reloaded:
            if not first:
                logging.warning(f"NOTE - The config file has been reloaded.")

            # Refresh the notifications handlers
            notif_handlers_list.clear()
            notif_handlers = getcfg("Notif_handlers", None)
            try:
                if notif_handlers is not None:
                    for handler in notif_handlers.split():
                        notif_plugin = __import__(handler)
                        notif_inst = notif_plugin.notif_class()
                        notif_handlers_list.extend([notif_inst])
            except:
                logging.error (f"Unable to load notification handler <{handler}> - Aborting.")
                sys.exit(1)

            # Clear out all current instances, forcing re-setup
            inst_dict.clear()
            globvars.keylen = 0
            globvars.hostlen = 0
            for key in cfg:                 # Get keylen and hostlen field widths across all monitored items for pretty printing
                if key.startswith("MonType_"):
                    montype_tag = key.split("_")[1]
                    for line in cfg:
                        try:
                            if line.startswith(montype_tag + "_"):
                                if len(line) > globvars.keylen:
                                    globvars.keylen = len(line)
                                host = lanmonfuncs.split_user_host_port(cfg[line].split(maxsplit=1)[0])[1]
                                if len(host) > globvars.hostlen:
                                    globvars.hostlen = len(host)
                        except Exception as e:
                            pass    # Issue will be caught and logged in the following setup code


        # Process each monitor type and item
        checked_have_LAN_access = False
        for line in cfg:
            if line.startswith("MonType_"):
                montype_tag = line.split("_", maxsplit=1)[1]
                montype_plugin = cfg[line]

                plugin = __import__(montype_plugin)

                # Process all items in cfg of this MonType
                for key in cfg:
                    if key.startswith(montype_tag + "_"):
                        # Instantiate the monitor item and call setup
                        # Line parsing (monline dict keys):
                        #   montype_xyz   pi@rpi3:80 CRITICAL  5m  xyz config specific
                        #   ^^^^^^^^^^^  key
                        #           ^^^  tag
                        #                 ^^^^^^^^^^ user_host_port
                        #                    ^^^^      host
                        #                            ^^^^^^^^  critical  (optional, case insensitive, saved as boolean)
                        #                                      ^^  check_interval (converted to sec)
                        #                                          ^^^^^^^^^^^^^^^^^^^  rest_of_line (parsed by plugin)

                        if key not in inst_dict:
                            # Set up the monitor item instance
                            try:
                                logging.debug("")
                                monline.clear()
                                monline["key"] = key
                                monline["tag"] = key.split("_", maxsplit=1)[1]
                                xx = cfg[key].split(maxsplit=1)
                                u_h_p = xx[0]
                                monline["user_host_port"] = u_h_p
                                _, host, _ = lanmonfuncs.split_user_host_port(u_h_p)
                                monline["host"] = host
                                monline["critical"] = False
                                yy = xx[1]
                                if yy.lower().startswith("critical"):
                                    monline["critical"] = True
                                    yy = yy.split(maxsplit=1)[1]
                                monline["check_interval"] = timevalue(yy.split(maxsplit=1)[0]).seconds
                                monline["rest_of_line"] = yy.split(maxsplit=1)[1]

                                inst = plugin.monitor()
                                rslt = inst.setup(monline)          # SETUP() CALL
                                    # setup successful returns RTN_PASS - remembered in inst_dict as instance pointer
                                    # setup hard fail  returns RTN_FAIL - remembered in inst_dict as False
                                    # Some plugins may need to interrogate the target host during setup.
                                    #   If the interrogation fails (i.e., can't access), then the plugin.setup should return
                                    #   RTN_WARNING.  The warning is logged, but no entry in the inst_dict is made 
                                    #   so that setup is retried on each iteration.
                                logging.debug (f"setup() returned:  {rslt}")
                                if rslt == lanmonfuncs.RTN_FAIL:
                                    _msg = f"MONITOR SETUP FOR <{key}> FAILED.  THIS RESOURCE IS NOT MONITORED."
                                    for notif_handler in notif_handlers_list:
                                        notif_handler.log_event({"rslt":lanmonfuncs.RTN_WARNING, "notif_key":key,
                                                    "message":f"  WARNING: {key} - {host} - {_msg}"})
                                    inst_dict[key] = False
                                elif rslt == lanmonfuncs.RTN_WARNING:
                                    _msg = f"MONITOR SETUP FOR <{key}> FAILED.  WILL RETRY."
                                    for notif_handler in notif_handlers_list:
                                        notif_handler.log_event({"rslt":lanmonfuncs.RTN_WARNING, "notif_key":key,
                                                    "message":f"  WARNING: {key} - {host} - {_msg}"})
                                elif rslt == lanmonfuncs.RTN_PASS:
                                    inst_dict[key] = inst
                                else:
                                    logging.critical (f"Setup for <{key}> returned illegal value {rslt} - Aborting.")
                                    sys.exit(1)
                            except Exception as e:
                                logging.warning (f"Malformed monitor item <{key}> - skipped:\n  {e}")
                                inst_dict[key] = False
                                continue


                        # Execute eval_status() for the item
                        inst = False
                        if key in inst_dict:
                            inst = inst_dict[key]
                        if inst is not False:       # See above setup() call notes
                            if inst.next_run > datetime.datetime.now():
                                logging.debug (f"<{key}> not due - skipped")
                            else:
                                inst.next_run += datetime.timedelta(seconds=inst.check_interval)

                                # For items that run >= daily, set the daily run time, if defined
                                if first  and  getcfg("DailyRuntime", False)  and  (inst.check_interval >= 86400):
                                    try:
                                        target_hour   = int(getcfg("DailyRuntime").split(":")[0])
                                        target_minute = int(getcfg("DailyRuntime").split(":")[1])
                                        inst.next_run = inst.next_run.replace(hour=target_hour, minute=target_minute, second=0, microsecond=0)
                                        logging.debug (f"Adjusted next_run:  {inst.next_run}")
                                    except Exception as e:
                                        logging.error (f"Cannot parse <DailyRuntime> in config:  {getcfg('DailyRuntime')} - Aborting")
                                        sys.exit(1)

                                # For checks to be run on remote hosts, ensure LAN access by pinging the config Gateway host.  Do only once per active serviceloop.
                                if inst.host != "local"  and  not checked_have_LAN_access:
                                    checked_have_LAN_access = True
                                    have_LAN_access = lanmonfuncs.check_LAN_access()
                                    if not have_LAN_access:
                                        logging.warning(f"WARNING:  NO ACCESS TO LAN ({getcfg('Gateway')}) - Checks run on remote hosts are skipped for this iteration.")
                                    else:
                                        logging.debug(f"LAN access confirmed.  Proceeding with checks run on remote hosts.")

                                if inst.host == "local" or have_LAN_access: 
                                    rslt = inst.eval_status()                               # EVAL_STATUS() CALL
                                    logging.debug (f"eval_status() returned:  {rslt}")

                                    for notif_handler in notif_handlers_list:
                                        notif_handler.log_event(rslt)

    
        for notif_handler in notif_handlers_list:
            notif_handler.each_loop()

        for notif_handler in notif_handlers_list:
            notif_handler.renotif()

        for notif_handler in notif_handlers_list:
            notif_handler.summary()

        if not globvars.args.service:
            sys.exit(0)

        first = False
        time.sleep (timevalue(getcfg("ServiceLoopTime")).seconds)


def int_handler(signal, frame):
    logging.warning(f"Signal {signal} received.  Exiting.")
    sys.exit(1)
signal.signal(signal.SIGINT,  int_handler)      # Ctrl-C
signal.signal(signal.SIGTERM, int_handler)      # kill


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=__doc__ + __version__, formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument('-p', '--print-log', action='store_true',
                        help="Print the tail end of the log file (last 40 lines).")
    parser.add_argument('-v', '--verbose', action='count',
                        help="Display OK items in non-service mode. (-vv for debug logging)")
    parser.add_argument('--config-file', default=CONFIG_FILE,
                        help=f"Path to config file (default <{CONFIG_FILE}>).")
    parser.add_argument('--service', action='store_true',
                        help="Enter endless loop for use as a systemd service.")
    parser.add_argument('-V', '--version', action='version', version='%(prog)s ' + __version__,
                        help="Return version number and exit.")
    globvars.args = parser.parse_args()
    
    logfile_override = True  if not globvars.args.service  else False
    try:
        loadconfig(globvars.args.config_file, cfglogfile_wins=logfile_override)
    except Exception as e:
        logging.error(f"Failed loading config file <{globvars.args.config_file}> - Aborting.\n  {e}")
        sys.exit(1)


    logging.warning (f"========== {os.path.basename(__file__)} ({__version__}) ==========")


    # Python min version check
    py_version = float(sys.version_info.major) + float(sys.version_info.minor)/10
    if py_version < PY_MIN_VERSION:
        logging.error (f"Current Python version {py_version} is less than minimum required version {PY_MIN_VERSION}.  Aborting.")
        sys.exit(1)


    # funcs3 min version check
    if not funcs3_min_version_check(FUNCS3_MIN_VERSION):
        logging.error(f"funcs3 module must be at least version <V{FUNCS3_MIN_VERSION}>.  Found <{funcs3_version}>.  Aborting.")
        sys.exit(1)
    else:
        logging.debug(f"funcs3 module version <{funcs3_version}> (min required <V{FUNCS3_MIN_VERSION}>)")


    # Print the tail end of the log file
    if globvars.args.print_log:
        _fp = getcfg("LogFile")
        if not os.path.isabs(_fp):
            _fp = os.path.join(PROGDIR, _fp)
        subprocess.run(["tail", "-40", _fp])
        sys.exit()


    main()
    sys.exit()