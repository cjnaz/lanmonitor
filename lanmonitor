#!/usr/bin/env python3
"""LAN monitor

Monitor status of items on the local network, such as services, hosts, file system age, etc.
Plugins are provided for these items, and additional plugins may easily be added:
    SELinux status
    Hosts ping response
    Systemd services active and running
    Web pages responding with expected text
    Processes existing
    Filesystem age

Operates interactively with --once switch, or as a service (loop forever and controlled via systemd or other).
"""

__version__ = "V0.6 210415"

#==========================================================
#
#  Chris Nelson, 2021
#
# V0.6 200415  Refactored to checker plugin model, many other changes
# V0.5 200312  Added checks on other hosts via ssh.
# V0.4 200304  Added StartupDelay for service mode.  Added SELinux check.
# V0.3 200226  Bug fix for files mod time vs. create time
# V0.2 210207  Added age info to Activity log
# V0.1 210129  Initial
#
# Changes pending
#   
#==========================================================

import sys
import argparse
import time
import datetime
import os.path
import signal       # For keyboard interrupt handler


sys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), '../funcs3/'))
from funcs3 import loadconfig, getcfg, cfg, setuplogging, logging, funcs3_min_version_check, funcs3_version

import lanmonfuncs


# Configs / Constants
PY_MIN_VERSION = 3.6
FUNCS3_MIN_VERSION = 0.5
CONFIG_FILE =     os.path.join(os.path.dirname(os.path.realpath(__file__)), 'lanmonitor.cfg')
LOG_FILE =        os.path.join(os.path.dirname(os.path.realpath(__file__)), "log_lanmonitor.txt")
SMTP_CREDS_FILE = os.path.join(os.path.expanduser("~"), "creds_SMTP")

py_version = float(sys.version_info.major) + float(sys.version_info.minor)/10
if py_version < PY_MIN_VERSION:
    print (f"ERROR:  Current Python version {py_version} is less than minimum required version {PY_MIN_VERSION} - Aborting.")
    sys.exit(1)


def main():
    first = True

    loadconfig(cfgfile = lanmonfuncs.args.config_file) #, cfgloglevel=10)
    notifs = lanmonfuncs.notif_handler()

    while 1:
        loadconfig(cfgfile = lanmonfuncs.args.config_file) #, cfgloglevel=10)

        if lanmonfuncs.args.once:
            if lanmonfuncs.args.verbose == 1:
                logging.getLogger().setLevel(logging.INFO)
            elif lanmonfuncs.args.verbose == 2:
                logging.getLogger().setLevel(logging.DEBUG)
            else:
                logging.getLogger().setLevel(logging.WARNING)
        else:               # In non-once mode, logging level is from config file
            if first:
                time.sleep (lanmonfuncs.convert_time(getcfg('StartupDelay'))[0])
                first = False

        for key in cfg:
            if key.startswith("MonType_"):
                montype_tag = key.split("_")[1]
                montype_plugin = cfg[key]
 
                plugin = __import__(montype_plugin)

                keylen = 0          # Get longest len of key and host strings of this type for pretty printing
                hostlen = 0
                for line in cfg:
                    if line.startswith(montype_tag + "_"):
                        if len(line) > keylen:
                            keylen = len(line)
                        host = lanmonfuncs.split_user_host(cfg[line].split(maxsplit=2)[0])[1]
                        if len(host) > hostlen:
                            hostlen = len(host)                        

                for line in cfg:    # Process all lines in cfg of this type
                    if line.startswith(montype_tag + "_"):
                        monline = {}
                        monline["key"] = line
                        monline["keylen"] = keylen
                        monline["tag"] = line.split("_", 1)[1]
                        xx = cfg[line].split(maxsplit=1)
                        monline["user_host"], monline["host"] = lanmonfuncs.split_user_host(xx[0])
                        monline["hostlen"] = hostlen
                        monline["critical"] = False
                        monline["rest_of_line"] = xx[1]
                        if monline["rest_of_line"].startswith("CRITICAL"):
                            monline["critical"] = True
                            monline["rest_of_line"] = monline["rest_of_line"].split(maxsplit=1)[1]

                        inst = plugin.monitor()
                        notifs.log_event(inst.eval_status(monline))
        
        notifs.renotif()
        notifs.summary()

        if lanmonfuncs.args.once:
            sys.exit(0)

        time.sleep (lanmonfuncs.convert_time(getcfg('RecheckInterval'))[0])


def keyboardInterruptHandler(signal, frame):
    print("KeyboardInterrupt (ID: {}) has been caught. Cleaning up...".format(signal))
    sys.exit(0)
signal.signal(signal.SIGINT, keyboardInterruptHandler)



if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=__doc__ + __version__, formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument('-1', '--once', action='store_true',
                        help="Single run mode.  Logging is to console rather than file.")
    parser.add_argument('-v', '--verbose', action='count',
                        help="Display OK items in --once mode. (Set by LoggingLevel in config file for non --once mode.)")
    parser.add_argument('--config-file', default=CONFIG_FILE,
                        help=f"Path to config file (default <{CONFIG_FILE}>).")
    parser.add_argument('--log-file', default=LOG_FILE,
                        help=f"Path to log file (default <{LOG_FILE}>).")
    parser.add_argument('--smtp-creds-file', default=SMTP_CREDS_FILE,
                        help=f"Path to SMTP credentials file (default <{SMTP_CREDS_FILE}>).")
    parser.add_argument('-V', '--version', action='version', version='%(prog)s ' + __version__,
                        help="Return version number and exit.")
    lanmonfuncs.args = parser.parse_args()
    
    if lanmonfuncs.args.once:
        setuplogging(logfile=None)
    else:
        setuplogging(logfile=lanmonfuncs.args.log_file)
    
    if not funcs3_min_version_check(FUNCS3_MIN_VERSION):
        logging.error(f"ERROR:  funcs3 module must be at least version {FUNCS3_MIN_VERSION}.  Found <{funcs3_version}> - Aborting.")
        sys.exit(1)
    
    loadconfig(cfgfile = lanmonfuncs.args.smtp_creds_file) #, cfgloglevel=10)

    main()
    sys.exit()